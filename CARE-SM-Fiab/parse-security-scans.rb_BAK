require 'json'

def parse_trivy_json(output)
  # Parse Trivy JSON output and filter for CRITICAL and HIGH vulnerabilities.
  # Returns an array of filtered vulnerabilities across all targets.
  begin
    data = JSON.parse(output)
    filtered_vulns = []
    data.each do |result|
      next unless result['Vulnerabilities']
      result['Vulnerabilities'].each do |vuln|
        severity = vuln['Severity']&.upcase
        if %w[CRITICAL HIGH].include?(severity)
          filtered_vulns << {
            'Target' => result['Target'] || 'Unknown',
            'VulnerabilityID' => vuln['VulnerabilityID'] || 'N/A',
            'PkgName' => vuln['PkgName'] || 'N/A',
            'InstalledVersion' => vuln['InstalledVersion'] || 'N/A',
            'FixedVersion' => vuln['FixedVersion'] || 'N/A',
            'Severity' => severity,
            'Title' => vuln['Title'] || 'N/A',
            'Description' => vuln['Description'] || 'N/A'
          }
        end
      end
    end
    filtered_vulns
  rescue JSON::ParserError
    nil # Not valid JSON; try table parsing
  end
end

def parse_trivy_table(output)
  # Parse Trivy default table output using regex. Less reliable than JSON.
  # Filters for CRITICAL and HIGH severities. Assumes standard table format with | separators.
  filtered_vulns = []
  lines = output.split("\n")
  in_table = false
  target = 'Unknown' # Default if no target detected
  lines.each do |line|
    line = line.strip
    if line.match(/^\|.*\|$/) && line.include?('VulnerabilityID')
      in_table = true
      next # Skip header
    end
    if in_table && line.match(/^\|.*\|$/) && line.count('|') >= 6 # At least 6 columns
      parts = line.split('|').map(&:strip).reject(&:empty?)
      next if parts.length < 6
      vuln_id = parts[0] || 'N/A'
      pkg_name = parts[1] || 'N/A'
      installed_ver = parts[2] || 'N/A'
      fixed_ver = parts[3] || 'N/A'
      severity = parts[4]&.upcase || ''
      title = parts[5] || 'N/A'
      if %w[CRITICAL HIGH].include?(severity)
        filtered_vulns << {
          'Target' => target,
          'VulnerabilityID' => vuln_id,
          'PkgName' => pkg_name,
          'InstalledVersion' => installed_ver,
          'FixedVersion' => fixed_ver,
          'Severity' => severity,
          'Title' => title,
          'Description' => 'N/A' # Descriptions often follow; this is basic
        }
      end
    end
    in_table = false if in_table && line.start_with?('=')
  end
  filtered_vulns.empty? ? nil : filtered_vulns
end

def print_basic_output(vulns)
  # Print a simplified output: summary counts and basic list.
  if vulns.nil? || vulns.empty?
    puts 'No CRITICAL or HIGH vulnerabilities found.'
    return
  end

  critical_count = vulns.count { |v| v['Severity'] == 'CRITICAL' }
  high_count = vulns.count { |v| v['Severity'] == 'HIGH' }
  puts "Summary: CRITICAL: #{critical_count}, HIGH: #{high_count}"
  puts "\nHigh-Risk Vulnerabilities:"
  puts '-' * 80
  vulns.each do |vuln|
    puts "Target: #{vuln['Target']}"
    puts "  ID: #{vuln['VulnerabilityID']} | Package: #{vuln['PkgName']} | Installed: #{vuln['InstalledVersion']} | Fixed: #{vuln['FixedVersion']}"
    puts "  Severity: #{vuln['Severity']} | Title: #{vuln['Title']}"
    puts "  Description: #{vuln['Description'][0, 200]}..." if vuln['Description'] != 'N/A'
    puts
  end
end

if ARGV.empty?
  puts 'Usage: ruby trivy_parser.rb <trivy_output.txt or pipe from trivy>'
  exit 1
end

# Read input: either from file or stdin
output = if ARGV[0] == '-'
           $stdin.read
         else
           File.read(ARGV[0])
         end

# Try JSON first (recommended)
vulns = parse_trivy_json(output)
if vulns.nil?
  # Fallback to table parsing
  vulns = parse_trivy_table(output)
  if vulns.nil?
    puts 'Error: Could not parse output. Ensure it\'s valid Trivy output (JSON or table).'
    exit 1
  end
end

print_basic_output(vulns)
